---
layout: post
title: 22. 제네릭 컬렉션 활용
subtitle: 제네릭 컬렉션 활용
categories: study
tags: java
---

## Overview

제네릭 컬렉션에 대해 좀 더 알아본다.

## Vector&lt;E&gt;

**Vector&lt;E&gt;**(이하 Vector 또는 벡터)는 List&lt;E&gt; 인터페이스를 구현한 클래스로서 가변 개수의 배열이 필요할 때 적합하다.

벡터에 삽입되는 요소의 수가 많아지면 자동으로 크기가 조절된다.

요소는 벡터의 맨 마지막이나 중간에 삽입될 수 있다.

이 경우 벡터는 삽입되는 요소의 뒤에 있는 모든 요소들을 한 자리씩 뒤로 이동시킨다.

요소를 삭제하면 뒤의 요소들을 앞으로 하나씩 이동시킨다.

다음 표는 Vector&lt;E&gt; 컬렉션의 주요 메소드를 보여준다.

| 메소드 | 설명 |
| :---------- | :---------- |
| boolean add(E element) | 벡터의 맨 뒤에 element 추가 |
| void add(int index, E element) | 인덱스 index에 element를 삽입 |
| int capacity() | 벡터의 현재 용량 리턴 |
| boolean addAll(Collection&lt;? extends E&gt; c) | 컬렉션 c의 모든 요소를 벡터의 맨 뒤에 추가 |
| void clear() | 벡터의 모든 요소 삭제 |
| boolean contains(Object o) | 벡터가 지정된 객체 o를 포함하고 있으면 true 리턴 |
| E elementAt | 인덱스 index의 요소 리턴 |
| E get(int index) | 인텍스 index의 요소 리턴 |
| int indexOf(Object 0) | o와 같은 첫 번째 요소의 인덱스 리턴. 없으면 -1 리턴 |
| boolean isEmpty() | 벡터가 비어 잇으면 true 리턴 |
| E remove(int index) | 인덱스 index의 요소 삭제 |
| boolean remove(Object o) | 객체 o와 같은 첫 번째 요소를 벡터에서 삭제 |
| void removeAllElements() | 벡터의 모든 요소를 삭제하고 크기를 0으로 만듦 |
| int size() | 벡터가 포함하는 요소의 개수 리턴 |
| Object[] toArray() | 벡터의 모든 요소를 포함하는 배열 리턴 |

### 벡터 생성

벡터를 생성할 때, Vector&lt;E&gt;의 **E**에 요소로 사용할 타입을 지정해야 한다.

예를 들어 정수 값만 삽입 가능한 벡터를 만들고자 하면 다음과 같이 **E**에 *Integer*를 지정하여 벡터를 생성한다.

```java
Vector<Integer> v = new Vector<Integer>();
```

문자열만 다루는 벡터는 다음과 같이 생성할 수 있다.

```java
Vector<String> stringVector;            // 제네릭 컬렉션의 레퍼런스 변수 선언
stringVector = new Vector<String>();    // 문자열 벡터 선언
```

만일 Vector&lt;E&gt;에서 **E**에 구체적인 타입을 지정하지 않고 **Vector**로만 사용하는 경우 컴파일러는 경고 메시지를 출력한다.

생성된 벡터의 용량을 굳이 알 필요는 없다. 공간이 필요하면 자신의 용량을 스스로 조절하기 때문이다.

만일 용량을 초기에 설정하고자 한다면 다음과 같이 용량을 지정하는 생성자를 호출하면 된다.

```java
Vector<Integer> v = new Vector<Integer>(5); // 초기 용량이 5인 벡터 생성
```

### 벡터에 요소 삽입

벡터에 요소를 삽입할 때 `add()`를 사용한다. `add()`는 요소를 벡터의 맨 뒤에 삽입한다.

현재 벡터 `v`에 삽입할 수 있는 요소는 *Integer* 타입의 객체이므로 다음과 같이 하면 된다.

```java
v.add(new Integer(5));
v.add(new Integer(4));
v.add(new Integer(-1));
```

위 코드는 정수 5, 4, -1을 순서대로 벡터 `v`에 삽입한다.

그러나 *JDK 1.5*버전부터는 자동 박싱에 의해 다음과 같이 *int* 타입의 정수를 사용해도 자동으로 *Integer* 객체로 변환되어 삽입된다.

```java
v.add(5);   // 5 -> new Integer(5)로 변환되어 저장됨
v.add(4);
v.add(-1);
```

벡터 `v`에 *Integer* 외의 다른 타입의 객체를 삽입할 수 없다.

다음 코드는 오류가 발생한다.

```java
v.add("hello");
v.add(new Double(4.5));
v.add(new Person());
```

벡터에는 `null`도 삽입할 수 있기 때문에 벡터를 검색할 때 `null`이 있을 수 있음을 염두에 두어야 한다.

```java
v.add(null);
```

벡터의 중간에 요소 객체를 삽입할 수 있다. 예를 들어, 인덱스 2의 위치에 정수 100을 삽입하는 코드는 다음과 같다.

```java
v.add(2, 100);  // v.add(2, new Integer(100));과 동일
```

