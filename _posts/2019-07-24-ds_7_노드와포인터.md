---
layout: post
title: 7. 노드와 포인터
subtitle: 노드와 포인터
categories: study
tags: study datastructure
---

### Overview

데이터에 대한 저급한 표현은 순차 표현과 연결 표현으로 구분할 수 있다.

먼저 연결 데이터 표현에 대해 알아보기 전에 배열을 이용한 순서 리스트의 순차 표현에 대한 장단점을 살펴본다.

순차 표현의 장점은 리스트의 논리적 순서와 저장된 원소의 물리적 순서가 같아 표현이 간단하고 원소의 접근이 빠르다는 것이다.

연속된 메모리에 위치한 원소의 위치를 나타내는 인덱스는 직접 메모리 주소로 변환할 수 있기 때문에 빠른 임의 접근이 가능하다.

반면에 원소들 이 순차적으로 저장되기 때문에 원소의 삽입과 삭제가 어렵고 시간이 많이 걸리는 단점이 있다.

순차 표현에서는 리스트 원소의 순서가 연속적인 물리적 주소로 표현되기 때문에, 원소를 삽이하거나 삭제하기 위해서는 해당 원소의 위치 뒤에 있는 모든 원소를 뒤로 물리거나 앞으로 당겨야 한다.

이런 데이터의 이동은 원소수가 많은 리스트에서는 많은 오버헤드를 일으키게 된다.

또 리스트의 길이(원소의 수)가 임의로 늘어나고 줄어드는 상황에서는 배열의 크기를 미리 결정하기 힘들다.

이로 인해 배열의 **오버플로우**(overflow)나 과다한 메모리 할당으로 인한 저장 공간의 낭비와 비효율을 가져오기 쉽다.

예를 들어 다음과 같이 알파벳 순서로 된 성씨의 리스트 L이 있다고 하자.

> L = (Cho, Kim, Lee, Park, Yoo)

이것을 순차 표현으로 1차원 배열 L&#91;6&#93;에 저장하고 원소 &quot;Han&quot;을 새로 삽입한다고 하면 결과는 다음 그림과 같이 될 것이다.

![fig_1](/assets/img/study/ds/190724_fig_1.png "fig_1")

이 과정을 살펴보면 원소 &quot;Han&quot;은 &quot;Cho&quot; 다음에 삽입되어야 하기 때문에 먼저 &quot;Cho&quot; 다음에 빈 공간을 만들어야 한다.

따라서 &quot;Kim&quot;에서부터 &quot;Yoo&quot;까지를 모두 한 자리씩 뒤로 이동시키는 연산을 수행한 뒤 &quot;Han&quot;을 &quot;Kim&quot;이 있던 자리에 삽입했다.

그 결과로 리스트 L의 길이는 5에서 6으로 늘어났다.

만약 배열 L이 L&#91;5&#93;로 정의되었다면 &quot;Han&quot;을 삽입하려고 할 때 저장공간의 부족으로 오버플로우가 일어났을 것이다.

***

### 노드와 포인터

순차 표현에서의 이런 연산 시간과 저장 공간의 문제를 해결할 수 있는 방법으로 **비순차 표현**(nonsequential representation) 또는 **연결 표현**(linked representation)이 있다.

이 연결 표현에서는 순차 표현과 달리 원소의 물리적 순서가 리스트의 논리적 순서와 일치할 필요가 없다.

즉, 리스트의 원소는 메모리 어느 곳에 저장되어도 된다.

그러기 위해서는 원소를 저장할 때 그 원소의 다음 원소에 대한 주소도 함께 저장해야 한다.

이런 &lt;**원소, 주소**&gt;**쌍**의 저장 구조를 **노드**(node)라고 한다.

일반적으로 노드는 몇 개의 필드로 구성되는데, 이 필드들은 크게 데이터 필드와 링크 필드로 구분된다.

**데이터 필드**(data field)는 리스트의 **원소**(데이터 값)를 저장하는 곳이고 **링크 필드**(link field)는 **포인터**(pointer) 즉, 다른 노드의 주소값을 저장하는 곳이다.

이 포인터를 **링크**(link) 혹은 **참조**(reference)라고도 하는데, 모두 주소값을 표현한다.

변수 중에는 항상 주소 값만 저장하도록 선언된 것이 있는데 이것을 포인터 변수(pointer variable)이라고 한다.

***

### 참고 문서
- 이석호. (2004). *자료 구조와 JAVA*. 정익사.
